[{"categories":["leetcode"],"content":"题目 题目链接 在一个小城市里，有m个房子排成一排，你需要给每个房子涂上n种颜色之一（颜色编号为 1 到 n）。 有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。 我们将连续相同颜色尽可能多的房子称为一个街区。 比方说 houses = [1,2,2,3,3,2,1,1] ， 它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。 给你一个数组houses，一个m * n的矩阵cost和一个整数target，其中： houses[i]：是第i个房子的颜色，0表示这个房子还没有被涂色。 cost[i][j]：是将第i个房子涂成颜色j+1的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成target个街区。 如果没有可用的涂色方案，请返回-1。 m == houses.length == cost.length n == cost[i].length 1 \u003c= m \u003c= 100 1 \u003c= n \u003c= 20 1 \u003c= target \u003c= m 0 \u003c= houses[i] \u003c= n 1 \u003c= cost[i][j] \u003c= 10^4 ","date":"2021-05-04","objectID":"/1473/:1:0","tags":["leetcode","动态规划","三维DP"],"title":"1473. 粉刷房子 III","uri":"/1473/"},{"categories":["leetcode"],"content":"分析 具有重叠子问题特征,大眼一看就是动态规划题目. 假如动态规划做复杂度大概在 mnntarget \u003c= 1002020100,复杂度合适 可能的坑点:cost存在int溢出的可能.cost可能为0,只有0才能被涂色 dp[i][j][k]代表考虑第i个房子时刷为j颜色组成k个街区时的最小花费 dp[i][j][k] = min( dp[i][j][k], dp[i - 1][j][k]+cost, 相同颜色 dp[i-1][枚举not j][k-1]+cost 不同颜色 ) ","date":"2021-05-04","objectID":"/1473/:2:0","tags":["leetcode","动态规划","三维DP"],"title":"1473. 粉刷房子 III","uri":"/1473/"},{"categories":["leetcode"],"content":"提交代码 class Solution: def minCost(self, houses, cost, m, n, target): dp = [[[-1 for i in range(target + 1)] for j in range(n)] for k in range(m)] # cost = def getCost(color, idx): if houses[idx] == color: return 0 return cost[idx][color - 1] for j in range(n): if houses[0] == 0 or j + 1 == houses[0]: dp[0][j][1] = getCost(j + 1, 0) # dp[i][j][k] = min(dp[i - 1][j][k] + (cost[i - 1][j - 1]), dp[i - 1][notj][k - 1] + (cost[i - 1][j - 1])) def update(now, pre, cost): if pre == -1: return now if now == -1: return pre + cost return min(pre + cost, now) for i in range(1, m): for k in range(1, target + 1): for j in range(n): if houses[i] == 0 or j + 1 == houses[i]: c = getCost(j + 1, i) for pre in range(n): if pre == j: dp[i][j][k] = update(dp[i][j][k], dp[i - 1][j][k], c) else: dp[i][j][k] = update(dp[i][j][k], dp[i - 1][pre][k - 1], c) # print(dp) ans = -1 for i in range(n): ans = update(ans, dp[m - 1][i][target], 0) return ans ","date":"2021-05-04","objectID":"/1473/:3:0","tags":["leetcode","动态规划","三维DP"],"title":"1473. 粉刷房子 III","uri":"/1473/"},{"categories":["leetcode"],"content":"题目 题目链接 给你一个整数数组 nums ，你可以对它进行一些操作。 每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。 之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。 开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。 ","date":"2021-05-04","objectID":"/740/:1:0","tags":["leetcode","动态规划"],"title":"740. 删除并获得点数","uri":"/740/"},{"categories":["leetcode"],"content":"分析 存在递推关系,梳理简化下条件,实际上就是拿nums[i]的时候后续不能拿取nums[i]+1 对nums去重排序后得到新的nums,dp[i]j考虑第i的时候取与不取的最优代价. 递推关系如下: # c代表nums[i]的计数 if nums[i] - nums[i - 1] == 1: dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i] * c[nums[i]]) else: dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) dp[i][1] = dp[i][0] + nums[i] * c[nums[i]] ","date":"2021-05-04","objectID":"/740/:2:0","tags":["leetcode","动态规划"],"title":"740. 删除并获得点数","uri":"/740/"},{"categories":["leetcode"],"content":"提交代码 class Solution: def deleteAndEarn(self, nums): from collections import Counter c = Counter(nums) nums = sorted(c.keys()) n = len(nums) dp = [[0] * 2 for i in range(n)] dp[0][0] = 0 dp[0][1] = nums[0] * c[nums[0]] for i in range(1, n): if nums[i] - nums[i - 1] == 1: dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i] * c[nums[i]]) else: dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]) dp[i][1] = dp[i][0] + nums[i] * c[nums[i]] return max(dp[-1][0], dp[-1][1]) ","date":"2021-05-04","objectID":"/740/:3:0","tags":["leetcode","动态规划"],"title":"740. 删除并获得点数","uri":"/740/"},{"categories":null,"content":"这里完全就是一个随笔记录. 博客的目的也是不断记录自己探索的程度/路线吧. 如果一开始没想写这个博客,那么很多知识可能就丢在风中了. ","date":"2021-05-04","objectID":"/about/:0:0","tags":null,"title":"简介","uri":"/about/"},{"categories":["golang"],"content":"导读 解决以下问题: slice到底是什么,如何感知 和数组的区别 slice底层实现 常见的坑点 ","date":"2021-05-04","objectID":"/slice/:0:0","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"slice到底是什么 slice是建立在数组之上的一种抽象.可以由以下几种方式定义: func main(){ x := []string{\"a\", \"b\", \"c\", \"d\"} y := make([]string, 4) var z []string // 零值nil } ","date":"2021-05-04","objectID":"/slice/:1:0","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"和数组的区别 arry的定义方式是[n]定义(有以下几种种方式)，从定义上已经决定了长度. func main() { x := [5]int{1: 10, 3: 30} y := [...]int{1: 10, 3: 30} var z [3]string fmt.Println(x,y,z) } ","date":"2021-05-04","objectID":"/slice/:2:0","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"底层实现 ","date":"2021-05-04","objectID":"/slice/:3:0","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"数据结构 具体实现在runtime包下的slice.go文件 type slice struct { array unsafe.Pointer //array指向实际存储的连续内存数组. len int //len表示元素具体的个数. cap int // cap表示连续内存的长度. } ","date":"2021-05-04","objectID":"/slice/:3:1","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"扩容机制 下面的函数就是append操作时对slice结构做的调整: 这里面存在着惰性分配机制和对齐page等. 新老slice的cap作为计算的指标, func growslice(et *_type, old slice, cap int) slice { if raceenabled { callerpc := getcallerpc() racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice)) } if msanenabled { msanread(old.array, uintptr(old.len*int(et.size))) } if cap \u003c old.cap { panic(errorString(\"growslice: cap out of range\")) } if et.size == 0 { // append should not create a slice with nil pointer but non-zero len. // We assume that append doesn't need to preserve old.array in this case. return slice{unsafe.Pointer(\u0026zerobase), old.len, cap} } newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap } else { if old.len \u003c 1024 { newcap = doublecap } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } var overflow bool var lenmem, newlenmem, capmem uintptr // Specialize for common values of et.size. // For 1 we don't need any division/multiplication. // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant. // For powers of 2, use a variable shift. switch { case et.size == 1: lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u003e maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) \u003e maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026 31 } lenmem = uintptr(old.len) \u003c\u003c shift newlenmem = uintptr(cap) \u003c\u003c shift capmem = roundupsize(uintptr(newcap) \u003c\u003c shift) overflow = uintptr(newcap) \u003e (maxAlloc \u003e\u003e shift) newcap = int(capmem \u003e\u003e shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // The check of overflow in addition to capmem \u003e maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // type T [1\u003c\u003c27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d) // print(len(s), \"\\n\") // } if overflow || capmem \u003e maxAlloc { panic(errorString(\"growslice: cap out of range\")) } var p unsafe.Pointer if et.ptrdata == 0 { p = mallocgc(capmem, nil, false) // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory. p = mallocgc(capmem, et, true) if lenmem \u003e 0 \u0026\u0026 writeBarrier.enabled { // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata) } } memmove(p, old.array, lenmem) return slice{p, old.len, newcap} } ","date":"2021-05-04","objectID":"/slice/:3:2","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"坑点 很明显结构的定义不保证线程安全. 切片的copy,实质上只是struct中几个字段的copy,引用的内存地址会互相影响. 子切片会影响上层的切片/数组. func main(){ //这里的x换成切片也是同样的效果 x := [4]string{\"a\", \"b\", \"c\", \"d\"} y := make([]string, 4) var z []string // 零值nil y = x[2:3] y[0] = \"2\" z = x[:] z[3] = \"3\" //输出x,发现被修改了 fmt.Println(x[2], x[3]) } 子切片不回收,会导致父切片不能被gc回收. 如果存在扩容导致array(unsafe.Pointer)地址变更,那么和上层slice就完全不一致了 ","date":"2021-05-04","objectID":"/slice/:4:0","tags":["golang","slice"],"title":"Slice实现原理","uri":"/slice/"},{"categories":["golang"],"content":"基础 slice实现原理 channel实现原理,无缓冲和有缓冲 反射实现原理 select实现原理 sync.map实现原理 defer/recover原理,能捕获所有异常吗?(不能) context原理 sync.pool实现原理 STW 内存管理(分配,GC,读写混合屏障),逃逸分析(大小对象) GMP模型,goroutinue调度,抢占式调度(信号) pprof/trace 调优工具 ","date":"2021-05-04","objectID":"/review/:1:0","tags":["review"],"title":"golang 复习点","uri":"/review/"},{"categories":["python"],"content":"python 主要还是为了整理复习路线 ","date":"2021-05-03","objectID":"/review/:0:0","tags":["review"],"title":"python复习点","uri":"/review/"},{"categories":["python"],"content":"基础 ","date":"2021-05-03","objectID":"/review/:1:0","tags":["review"],"title":"python复习点","uri":"/review/"},{"categories":["python"],"content":"语法 ","date":"2021-05-03","objectID":"/review/:1:1","tags":["review"],"title":"python复习点","uri":"/review/"},{"categories":["python"],"content":"cpython ","date":"2021-05-03","objectID":"/review/:1:2","tags":["review"],"title":"python复习点","uri":"/review/"},{"categories":["python"],"content":"2和3的差别 编码和字符串 xrange和range print作为函数出现 ","date":"2021-05-03","objectID":"/review/:1:3","tags":["review"],"title":"python复习点","uri":"/review/"},{"categories":["python"],"content":"问题 GIL(多线程和多进程的使用,分IO密集和CPU密集) 内存管理(引用计数,GC,内存池) ","date":"2021-05-03","objectID":"/review/:2:0","tags":["review"],"title":"python复习点","uri":"/review/"}]